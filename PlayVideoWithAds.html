<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Video Player</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 20px; }
    .player { max-width: 800px; margin-bottom: 12px; position: relative; }
    video { width: 100%; height: auto; background: #000; display:block; }
    /*.controls-overlay { position: absolute; top: 10px; right: 10px; display:flex; gap:8px; z-index: 2000; }*/
    .controls-overlay {
      pointer-events: auto;
      position: absolute !important;
      top: 10px !important;
      right: 10px !important;
      left: auto !important;
      display: flex !important;
      gap: 8px;
      z-index: 2000;
    }
	
    /* let JS control FS visibility */
    #fsToggleBtn { display: inline-block; }

    .controls-overlay .skip-btn { pointer-events: auto; }
    .skip-btn { background: rgba(0,0,0,0.6); color: #fff; padding:6px 10px; border-radius:4px; border: none; cursor: pointer; display:none; }
    .skip-btn[disabled] { opacity: 0.5; cursor: not-allowed; }
    .ad-countdown { color:#fff; background: rgba(0,0,0,0.6); padding:6px 8px; border-radius:4px; display:none; }
    .ad-list { max-width:800px; margin-top: 18px; border:1px solid #ddd; padding:10px; border-radius:6px; }
    table { width:100%; border-collapse: collapse; }
    th, td { text-align:left; padding:6px 8px; border-bottom:1px solid #eee; font-size:14px; }
    th { background:#fafafa; }
    .current { background:#fffbe6; }
    a { color:#006; word-break: break-all; }
	/* Chrome, Edge, Safari */
	video::-webkit-media-controls-fullscreen-button {
  	display: none !important;
	}

	/* Firefox */
	video::-moz-fullscreen-button {
	  display: none !important;
	}

    video.fade-out {
      opacity: 0;
      transition: opacity 0.5s ease-out;
    }

    video.fade-in {
      opacity: 1;
      transition: opacity 0.5s ease-in;
    }

  </style>
</head>
<body>

<h2>Auto-play Ads (muted) with minimum skippable duration</h2>

<div class="player" id="playerWrap">
  <video id="mainVideo" controls preload="metadata" playsinline webkit-playsinline>
    <source src="file:///C:/Users/Willanson/Videos/0.mp4" type="video/mp4">
  </video>

  <div class="controls-overlay" aria-hidden="false">
	<button id="skipBtn" class="skip-btn" disabled>Skip in 5s</button>
    <button id="playPauseBtn" class="skip-btn">Play</button>
    <button id="muteBtn" class="skip-btn">Mute</button>
    <button id="fsToggleBtn" class="skip-btn" >Fullscreen</button>
    <button id="exitFsBtn" class="skip-btn" style="display:none">Exit Fullscreen</button>
  </div>
</div>

<div class="ad-list" id="adListContainer" style="display:none;">
  <strong>Ad playlist:</strong>
  <table id="adTable" aria-label="Ad playlist">
    <thead><tr><th>#</th><th>Ad URL</th><th>Interrupt @ (s)</th><th>Min ad play (s)</th></tr></thead>
    <tbody></tbody>
  </table>
</div>

<!-- Ad video (kept for legacy/overlay fallback but not used for primary ad playback) -->
<video id="adVideo" preload="metadata" style="display:none; position:absolute; z-index:1500; background:#000;" playsinline webkit-playsinline></video>

<script>
const RESUME_OFFSET = 3;
const SHOW_AD_PLAYLIST = false;

const ads = [
  { url: "file:///C:/Users/Willanson/Videos/1.mp4", interruptAt: 5, minPlay: 3 },
  { url: "file:///C:/Users/Willanson/Videos/2.mp4", interruptAt: 14, minPlay: 5 },
  { url: "https://www.w3schools.com/html/mov_bbb.mp4", interruptAt: 30, minPlay: 5 },
  { url: "file:///C:/Users/Willanson/Videos/3.mp4", interruptAt: 44, minPlay: 5 },
];

const mainVideo = document.getElementById('mainVideo');
const adVideo = document.getElementById('adVideo'); // kept for fallback but not primary ad playback
const skipBtn = document.getElementById('skipBtn');
//const unmuteBtn = document.getElementById('unmuteBtn');
const playPauseBtn = document.getElementById('playPauseBtn');
const muteBtn = document.getElementById('muteBtn');
const adTableBody = document.querySelector('#adTable tbody');
const playerWrap = document.getElementById('playerWrap');
const fsToggleBtn = document.getElementById('fsToggleBtn');
const exitFsBtn = document.getElementById('exitFsBtn');

// ensure always-visible controls are shown until we explicitly hide them
if (playPauseBtn) playPauseBtn.style.display = 'inline-block';
if (muteBtn) muteBtn.style.display = 'inline-block';


const originalMainSrc = mainVideo.querySelector('source') ? mainVideo.querySelector('source').src : mainVideo.src;

// overlay and its original parent (declare only once)
const controlsOverlay = document.querySelector('.controls-overlay');
const originalOverlayParent = controlsOverlay.parentElement;

// Ensure overlay is attached to wrapper and layout is applied immediately
if (controlsOverlay && originalOverlayParent && playerWrap) {
  // move overlay back into wrapper to guarantee correct positioning
  if (controlsOverlay.parentElement !== playerWrap) {
    playerWrap.appendChild(controlsOverlay);
  }
  // force overlay style (defensive)
  Object.assign(controlsOverlay.style, {
    position: 'absolute',
    top: '10px',
    right: '10px',
    left: 'auto',
    display: 'flex',
    gap: '8px',
    zIndex: '2000'
  });
}

// Defer initial visibility to the updater so it reflects actual fullscreen state
if (exitFsBtn) exitFsBtn.style.display = 'none';

let scheduledAds = ads.slice().sort((a,b)=>a.interruptAt-b.interruptAt);
let currentAd = null;
let currentInterruptPoint = null;
let adStartTimestamp = null;
let minPlayTimeout = null;
let countdownInterval = null;

// preserve/restore & gesture tracking
let prevMuted = mainVideo.muted;
let prevControls = mainVideo.controls;
let hadUserGesture = false;

function attachOverlayToFullscreenTree() {
  if (!controlsOverlay) return;
  const fsEl = document.fullscreenElement;

  // Not fullscreen: restore overlay to original container
  if (!fsEl) {
    if (controlsOverlay.parentElement !== originalOverlayParent) {
      originalOverlayParent.appendChild(controlsOverlay);
    }
    Object.assign(controlsOverlay.style, {
      position: 'absolute',
      top: '10px',
      right: '10px',
      left: 'auto',
      zIndex: '2000'
    });
    // Ensure exit button hidden when not fullscreen
    exitFsBtn.style.display = 'none';
    return;
  }

  // If wrapper is fullscreen, attach overlay to wrapper
  if (fsEl === playerWrap) {
    if (controlsOverlay.parentElement !== playerWrap) {
      playerWrap.appendChild(controlsOverlay);
    }
    Object.assign(controlsOverlay.style, {
      position: 'absolute',
      top: '10px',
      right: '10px',
      left: 'auto',
      zIndex: '2147483647'
    });
    // Ensure exit button shows when wrapper is fullscreen
    exitFsBtn.style.display = 'inline-block';
    return;
  }

  // Other fullscreen targets: leave overlay where it is
}

function updateFullscreenButtons() {
  if (!fsToggleBtn || !exitFsBtn) return;
  const isWrapperFs = (document.fullscreenElement === playerWrap);
  if (isWrapperFs) {
    fsToggleBtn.style.display = 'none';
    exitFsBtn.style.display = 'inline-block';
  } else {
    fsToggleBtn.style.display = 'inline-block';
    exitFsBtn.style.display = 'none';
  }
}

// initial UI sync after DOM/setup and after the overlay has been reattached
attachOverlayToFullscreenTree();
updateFullscreenButtons();

document.addEventListener('fullscreenchange', () => {
  attachOverlayToFullscreenTree();
  updateFullscreenButtons();
});

function startAdTimers(ad){
  adStartTimestamp = Date.now();
  clearTimeout(minPlayTimeout);
  minPlayTimeout = setTimeout(() => {
    // enable skip button and update text
    showSkipUI(true, false, 'Skip ad');
    // ensure unmute button label reflects current mute state
    updateCountdownDisplay(0);
  }, ad.minPlay * 1000);

  clearInterval(countdownInterval);
  countdownInterval = setInterval(() => {
    const elapsed = (Date.now() - adStartTimestamp)/1000;
    const remaining = Math.max(0, ad.minPlay - elapsed);
    updateCountdownDisplay(remaining);
  }, 200);
}

function cleanupAd(){
  clearTimeout(minPlayTimeout);
  clearInterval(countdownInterval);
  showSkipUI(false);
  exitFsBtn.style.display = 'none';

  // restore overlay to original parent if necessary
  if (controlsOverlay.parentElement !== originalOverlayParent) {
    originalOverlayParent.appendChild(controlsOverlay);
  }
  adStartTimestamp = null;            // <- clear this so fullscreen handler knows timers ended
  minPlayTimeout = null;             // <- clear timer reference (used in fullscreen handler logic)
  currentAd = null;
  mainVideo.onended = null;
  mainVideo.onerror = null;
}

function endAdAndResume(){
  const backup = mainVideo._adBackup || {};
  cleanupAd();

  // Pause current playback (ad) and fade
  mainVideo.pause();
  mainVideo.classList.add('fade-out');

  setTimeout(() => {
    // Restore original source
    const srcEl = mainVideo.querySelector('source');
    if (srcEl) {
      const orig = (srcEl.dataset && srcEl.dataset._original) ? srcEl.dataset._original : originalMainSrc;
      srcEl.src = orig;
      delete srcEl.dataset._original;
    } else if (backup.originalSrcValue) {
      mainVideo.src = backup.originalSrcValue;
    } else {
      mainVideo.src = originalMainSrc;
    }

    // restore element state that may have been changed for the ad
    mainVideo.load();
    mainVideo.controls = (backup.originalControls !== undefined) ? backup.originalControls : true;
    mainVideo.muted = prevMuted;

    // helper to perform seek/resume once metadata is ready
    const doSeekAndResume = () => {
      let seekTime = (backup.resumeAt !== undefined) ? backup.resumeAt : Math.max(0, (currentInterruptPoint || 0) - RESUME_OFFSET);
      if (typeof mainVideo.duration === 'number' && !isNaN(mainVideo.duration)) {
        seekTime = Math.min(seekTime, mainVideo.duration - 0.1);
      }
      mainVideo.currentTime = seekTime;
      mainVideo.classList.remove('fade-out');
      mainVideo.classList.add('fade-in');
      mainVideo.play().catch(()=>{});
    };

    // If metadata already available, run immediately; otherwise wait for loadedmetadata once.
    if (mainVideo.readyState >= 1) {
      doSeekAndResume();
    } else {
      const onMeta = () => {
        mainVideo.removeEventListener('loadedmetadata', onMeta);
        doSeekAndResume();
      };
      mainVideo.addEventListener('loadedmetadata', onMeta);
    }

    // Restore overlay to its original parent so controls are back in the normal place
    if (controlsOverlay && controlsOverlay.parentElement !== originalOverlayParent) {
      originalOverlayParent.appendChild(controlsOverlay);
    }
    // restore control visibility
    if (playPauseBtn) playPauseBtn.style.display = 'inline-block';
    if (muteBtn) muteBtn.style.display = 'inline-block';

    // clear backup and ad state
    delete mainVideo._adBackup;
    currentInterruptPoint = null;
    adStartTimestamp = null;
    minPlayTimeout = null;
  }, 250);
}

// Initialize button labels based on current video state
function syncControlsState() {
  playPauseBtn.textContent = mainVideo.paused ? 'Play' : 'Pause';
  muteBtn.textContent = mainVideo.muted ? 'Unmute' : 'Mute';
}

// Click handlers
playPauseBtn.addEventListener('click', () => {
  if (mainVideo.paused) {
    mainVideo.play().catch(()=>{});
  } else {
    mainVideo.pause();
  }
  syncControlsState();
});
muteBtn.addEventListener('click', () => {
  // Treat this as an explicit user gesture
  hadUserGesture = true;

  // Toggle mute and persist the user's choice for resume/ads
  mainVideo.muted = !mainVideo.muted;
  prevMuted = mainVideo.muted;

  // Update both labels immediately
  updateMuteButton();

  // If ad was paused due to autoplay restrictions, try to resume
  if (!mainVideo.muted && mainVideo.paused) mainVideo.play().catch(()=>{});
});

function playAd(ad){
  // debug
  console.log('playAd called', ad);

  currentAd = ad;
  currentInterruptPoint = mainVideo.currentTime;

  // Backup original state
  const sourceEl = mainVideo.querySelector('source');
  const originalSrcValue = sourceEl ? sourceEl.src : mainVideo.src;
  prevMuted = mainVideo.muted;
  prevControls = mainVideo.controls;

  // Pause & fade current content, and prepare overlay
  mainVideo.pause();
  mainVideo.classList.add('fade-out');

  // Show skip UI immediately (disabled until minPlay expires)
  showSkipUI(true, true, `Skip in ${Math.ceil(ad.minPlay)}s`);

  attachOverlayToFullscreenTree();

  // make sure primary controls remain visible while ad plays
  if (muteBtn) muteBtn.style.display = 'inline-block';
  if (playPauseBtn) playPauseBtn.style.display = 'inline-block';

  // If page is currently fullscreen, ensure the overlay is in the visible subtree
  if (document.fullscreenElement === mainVideo || document.fullscreenElement === playerWrap) {
    try { playerWrap.appendChild(controlsOverlay); } catch(e) { /* ignore */ }
  }

  setTimeout(() => {
    // Swap source to ad
    if (sourceEl) {
      sourceEl.dataset._original = originalSrcValue;
      sourceEl.src = ad.url;
    } else {
      mainVideo.src = ad.url;
    }

    // ensure overlay is attached to the current fullscreen tree before attempting play
    attachOverlayToFullscreenTree();

    // Capture the gesture and muted state at the moment we prepare the ad
    const gestureAtStart = hadUserGesture;
    const prevMutedAtStart = prevMuted;

    // Autoplay rules:
    // - If we have not seen a user gesture at start, force mute to improve autoplay reliability.
    // - If the user already interacted before this point, preserve their preference captured above.
    if (!gestureAtStart) {
      mainVideo.muted = true;
    } else {
      mainVideo.muted = prevMutedAtStart;
    }

    mainVideo.controls = false;
    mainVideo.load();
    mainVideo.currentTime = 0;

    // Attempt to play
    mainVideo.play().then(() => {
      // After play resolves, apply the CURRENT user preference (not the captured one).
      // This lets the user click mute/unmute while play() was pending and have that choice respected.
      if (hadUserGesture) {
        mainVideo.muted = prevMuted;
      }

      startAdTimers(ad);
      updateMuteButton();

      // If currently in fullscreen, ensure overlay is visible on the wrapper
      if (document.fullscreenElement === playerWrap) {
        if (controlsOverlay.parentElement !== playerWrap) {
          playerWrap.appendChild(controlsOverlay);
        }
      } else if (document.fullscreenElement === mainVideo) {
        // Do nothing; do not attempt to reroute or exit fullscreen here
      }

    }).catch(err => {
      // Autoplay blocked: remain muted and rely on user gesture to start/unmute
      console.warn('Ad autoplay failed on mainVideo:', err);
      updateMuteButton();
    });

    // Ensure end/error handlers
    mainVideo.onended = () => { endAdAndResume(); };
    mainVideo.onerror = () => { endAdAndResume(); };

    mainVideo.classList.remove('fade-out');
    mainVideo.classList.add('fade-in');

    // Store backup info for resume
    mainVideo._adBackup = {
      originalSrcValue,
      originalControls: prevControls,
      resumeAt: Math.max(0, (currentInterruptPoint || 0) - RESUME_OFFSET)
    };

  }, 250);
}

function renderAdTable(){
  if (!adTableBody) return;
  adTableBody.innerHTML = "";
  scheduledAds.forEach((ad,i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${i+1}</td><td><a href="${ad.url}" target="_blank" rel="noopener">${ad.url}</a></td><td>${ad.interruptAt}</td><td>${ad.minPlay}</td>`;
    adTableBody.appendChild(tr);
  });
}
renderAdTable();
document.getElementById('adListContainer').style.display = SHOW_AD_PLAYLIST ? '' : 'none';

// Keep labels in sync when video changes state outside our buttons
mainVideo.addEventListener('play',  syncControlsState);
mainVideo.addEventListener('pause', syncControlsState);
mainVideo.addEventListener('volumechange', () => {
  prevMuted = mainVideo.muted;
  updateMuteButton();
});

mainVideo.addEventListener('loadedmetadata', syncControlsState);
mainVideo.addEventListener('ended', () => {
  // After ending, show Play to indicate the next action
  playPauseBtn.textContent = 'Play';
});
mainVideo.addEventListener('timeupdate', () => {
  if (currentAd) return;
  const t = mainVideo.currentTime;
  for (let i=0;i<scheduledAds.length;i++){
    const ad = scheduledAds[i];
    if (t >= ad.interruptAt && t < ad.interruptAt + 0.5) {
      scheduledAds.splice(i,1);
      renderAdTable();
      playAd(ad);
      break;
    }
  }
});
function showSkipUI(show, disabled = true, text = '') {
  if (show) {
    skipBtn.style.display = 'inline-block';
    skipBtn.disabled = !!disabled;
    skipBtn.textContent = text || skipBtn.textContent || 'Skip ad';
  } else {
    skipBtn.style.display = 'none';
    skipBtn.disabled = true;
    skipBtn.textContent = '';
  }
}
// Update mute button label to match current state
function updateMuteButton() {
  if (muteBtn) muteBtn.textContent = mainVideo.muted ? 'Unmute' : 'Mute';
}

// Call once at startup
syncControlsState();

skipBtn.addEventListener('click', ()=>{
  if (!currentAd) return;
  const elapsed = (Date.now() - adStartTimestamp)/1000;
  if (elapsed < currentAd.minPlay) return;
  endAdAndResume();
});

fsToggleBtn.addEventListener('click', () => {
  if (!document.fullscreenElement) {
    playerWrap.requestFullscreen().then(() => updateFullscreenButtons()).catch(()=>{});
  }
});

exitFsBtn.addEventListener('click', () => {
  if (document.fullscreenElement) {
    document.exitFullscreen().then(() => updateFullscreenButtons()).catch(()=>{});
  }
});

function updateCountdownDisplay(remaining){
  if (remaining <= 0) {
    skipBtn.textContent = 'Skip ad';
  } else {
    skipBtn.textContent = `Skip in ${Math.ceil(remaining)}s`;
  }
}

// Keep adVideo reposition/fallback handling (not primary path when using mainVideo for ads)
window.addEventListener('resize', repositionAd);
window.addEventListener('scroll', repositionAd);
function repositionAd(){
  if (adVideo.style.display === 'none') return;
  const rect = mainVideo.getBoundingClientRect();
  adVideo.style.left = rect.left + 'px';
  adVideo.style.top = rect.top + 'px';
  adVideo.style.width = mainVideo.clientWidth + 'px';
  adVideo.style.height = mainVideo.clientHeight + 'px';
}

</script>

</body>
</html>
